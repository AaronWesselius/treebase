#!/usr/bin/perl

use CIPRES::TreeBase::DBIUtil;
use CIPRES::TreeBase::RecDumper;
use Getopt::Long;
use Pod::Usage;
use strict;

my @tables; # database table to dump out
my $outhandle = \*STDOUT;      # handle to write dump to
my $with_progress_meter = 0;   # switch to print a progress meter
my $with_inserts = 1;          # write insert statements
my $with_creates = 0;          # write create statements
my $name_file_after_table = 0; # name output file after table

# get command line options, see Getopt::Long
GetOptions(
	'name-after-table' => \$name_file_after_table,
	'creates!'  => \$with_creates,
	'inserts!'  => \$with_inserts,
	'progress!' => \$with_progress_meter,
	'user=s'    => \$ENV{'TREEBASE_DB_USER'},
	'pass=s'    => \$ENV{'TREEBASE_DB_PASS'},
	'dsn=s'     => \$ENV{'TREEBASE_DB_DSN'},
	'table=s'   => \@tables,
	'help|?'    => sub { pod2usage( '-verbose' => 0 ) }, # see Pod::Usage
	'man'       => sub { pod2usage( '-verbose' => 1 ) }, # see Pod::Usage
	'all'       => sub { @tables = get_all_tables() },
	'file=s'    => sub {
		my $file = pop;
		open my $fh, '>', $file 
			or pod2usage( 
				'-msg'     => "Couldn't write output file '$file': $!; aborting",
				'-verbose' => 0,
				'-exitval' => 1 
			); # see Pod::Usage
		$outhandle = $fh;
	},	
) || pod2usage( '-verbose' => 0, '-exitval' => 1 );

# need at least one table, see Pod::Usage
pod2usage( 
	'-verbose' => 0, 
	'-exitval' => 1, 
	'-msg'     => 'Need at least one table to dump, aborting' 
) unless @tables;

# need at least one action, see Pod::Usage
pod2usage(
	'-verbose' => 0, 
	'-exitval' => 1, 
	'-msg'     => 'Need at least one operation to write out (--inserts and/or --creates), aborting'
) unless $with_creates or $with_inserts;

# create database handle
my $dbh = get_handle();

for my $table ( @tables ) {
	# only using these two functions once, so for clarity as to where they
	# originate let's use the fully qualified names.
    my @names = CIPRES::TreeBase::DBIUtil::get_colnames($dbh, $table); 
    my @types = CIPRES::TreeBase::DBIUtil::get_coltypes($dbh, $table);
    
    # instantiate a RecDumper object, which will format a row-as-array
    # into an insert statement
    my $dumper = CIPRES::TreeBase::RecDumper->new(
	    'FIELDS' => \@names,
	    'TYPES'  => \@types,
	    'TABLE'  => $table
	) or die "Couldn't instantiate CIPRES::TreeBase::RecDumper";
	
	# give dumper the output handle to write to, i.e. either STDOUT,
	# or a file specified on the command line, or the table name
	if ( $name_file_after_table ) {
		close $outhandle;
		open my $fh, '>', "${table}.sql" or die $!;
		$outhandle = $fh;
	}
    $dumper->set_output($outhandle);
    
    if ( $with_creates ) {
    	print $outhandle "CREATE TABLE $table;\n";    	
    }
    
    if ( $with_inserts ) {
    	# get all rows from $table
		my $q = qq{select * from $table};
		my $sth = $dbh->prepare($q);
		$sth->execute();
		
		my $row;
		
		# if --progress is provided, print out progress counter
		if ( $with_progress_meter ) {
		    my $count = 0;
		    while ( $row = $sth->fetchrow_arrayref ) {
				++$count;
				$dumper->rec(@$row);
				print STDERR "\r$count" if $count % 1000 == 0;
		    }
		} 
		
		# if --noprogress or default, just dump the records
		else {
			while ( $row = $sth->fetchrow_arrayref ) {
		    	$dumper->rec(@$row);
			}
		}
		
		# finish the statement handler
		$sth->finish();
		
		# add line break if we're printing a progress counter
		print STDERR "\n" if $with_progress_meter;
    }
}

# disconnect from database
$dbh->disconnect;
exit 0;

sub get_all_tables {
	my $dbh = get_handle();
	my $sth = $dbh->prepare('SELECT * FROM SYSCAT.TABLES');
	my @fetched_tables;
	$sth->execute();
	while ( my $row = $sth->fetchrow_hashref ) {
		if ( $row->{'DEFINER'} =~ /TBASE2/ ) {
			push @fetched_tables, $row->{'TABNAME'};
		}
	}
	return @fetched_tables;
}

sub get_handle {
	my $dbh = CIPRES::TreeBase::DBIUtil->dbh
		or die "Couldn't connect to database: " . DBI->errstr;
	$dbh->{'RaiseError'} = 1;	
	return $dbh;
}
